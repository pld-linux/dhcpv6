--- /dev/null	2007-02-06 10:40:24.955607220 -0500
+++ dhcp-0.10/dhcp6r.8	2007-02-09 00:16:08.000000000 -0500
@@ -0,0 +1,213 @@
+.\"
+.\" Copyright (C) NEC Europe Ltd., 2003
+.\" All rights reserved.
+.\"
+.\" Redistribution and use in source and binary forms, with or without
+.\" modification, are permitted provided that the following conditions
+.\" are met:
+.\" 1. Redistributions of source code must retain the above copyright
+.\"    notice, this list of conditions and the following disclaimer.
+.\" 2. Redistributions in binary form must reproduce the above copyright
+.\"    notice, this list of conditions and the following disclaimer in the
+.\"    documentation and/or other materials provided with the distribution.
+.\" 3. Neither the name of the project nor the names of its contributors
+.\"    may be used to endorse or promote products derived from this software
+.\"    without specific prior written permission.
+.\"
+.\" THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+.\" SUCH DAMAGE.
+.\"
+.de Id
+.ds Dt \\$4
+..
+.Id $Id$
+.TH dhcp6r 8 "15 March 2004" "dhcp6r" "Linux System Manager's Manual"
+.SH NAME
+dhcp6r \- DHCPv6 relay agent
+.SH SYNOPSIS
+.B dhcp6r
+[
+.B \-d
+] [
+.I client-options
+] [
+.I server-options
+]
+.SH DESCRIPTION
+.B dhcp6r
+acts as DHCPv6 relay agent forwarding DHCPv6 messages from clients
+to servers and vice versa.  DHCPv6 messages from clients are received
+at UDP port 547, they are forwarded to one or more DHCPv6
+servers by multicast and/or unicast.  DHCPv6 messages from
+servers to clients are also received at UDP port 547 and
+forwarded by unicast only.
+.PP
+DHCPv6 messages received by multicast at a certain IPv6
+interface are never forwarded by multicast to the same
+interface.
+.PP
+If no options are present, the relay agent receives messages
+by unicast and multicast at all IPv6 interfaces, and
+all messages are forwarded to all IPv6 interfaces by
+multicast with the exception mentioned in the previous
+paragraph.
+.PP
+If one or more 
+.I client-options
+are present, then messages are only received as specified by 
+the client options.  If one or more
+.I server-options
+are present, then messages are only forwarded as specified by 
+the server options.
+.SH CLIENT-OPTIONS
+If no
+.I client-options
+are present, the relay receives
+messages by multicast and unicast at all IPv6 interfaces.
+.PP
+If one or more client options are present, then messages
+are only received as specified by the
+.IR client-options .
+.PP
+In any case, the relay receives client messages by
+unicast.
+.TP
+.B \-cu
+This option can be used to configure the client
+such that it receives messages from clients or other
+relay agents by unicast only.
+It does not have any effect if a 
+.B \-cm
+option is present.
+.TP
+.BI "\-cm " INTERFACE
+Accept client messages multicasted at IPv6
+interface
+.IR INTERFACE .
+The others are receiving 
+only unicast messages. For specifying a set of
+interfaces, an instance of this option is
+required for each interface. 
+.SH SERVER-OPTIONS
+If no
+.I server-options
+are present, the relay forwards
+messages received from clients by multicast and unicast 
+to all IPv6 interfaces, except the one, which the packet
+was received on.
+.PP
+If one or more
+.I server-options
+are present, then messages are forwarded as specified by the
+.IR server-options .
+.TP
+.BI "\-sm " INTERFACE
+Forward all received client messages by multicast
+at IPv6 interface
+.IR INTERFACE .
+For specifying a set of interfaces, an instance of this
+option is required for each interface.
+.TP
+.BI "\-su " ADDRESS
+Forward all received client messages by unicast
+to the IPv6 address
+.IR ADDRESS .
+For specifying a set
+of addresses, an instance of this option is
+required for each address.
+.TP
+.BI "\-sf " INTERFACE+ADDRESS
+Forward all received client messages by unicast
+to the IPv6 address
+.I ADDRESS
+through the IPv6 interface
+.IR INTERFACE .
+For specifying a set of combinations of
+interfaces and addresses, an instance of this
+option is required for each combination.
+.PP
+The 
+.BR \-sm ,
+.BR \-su ,
+and 
+.B \-sf 
+options can be combined in arbitrary ways.
+.SH OTHER OPTIONS
+.TP
+.B \-d
+If this option is not present, dhcp6r will dump logging
+information into the file /var/log/dhcp6r.log.  If the 
+option is present, logging information will be sent to stderr
+instead.
+.SH EXAMPLES
+The following examples are shown as given to the shell:
+.TP
+.SH dhcp6r
+Receive messages from clients at all IPv6
+interfaces by multicast and by unicast, and
+forward them to all (other) IPv6 interfaces
+by multicast.
+.TP
+.SH dhcp6r -cu
+Receive messages from clients by unicast only,
+and forward them to all (other) IPv6 interfaces by
+multicast.
+.TP
+.SH dhcp6r -cm eth0 -cm eth2
+Receive messages from clients at interfaces
+eth0 and eth2 by multicast and by unicast, and
+forward them to all IPv6 interfaces by
+multicast (except the one at which the message
+was received by multicast).
+.TP
+.SH dhcp6r -cm eth0 -cm eth2 -sm eth1
+Receive messages from clients at interfaces
+eth0 and eth2 by multicast and by unicast, and
+forward them to interfaces eth1 by multicast.
+.TP
+.nf
+.SH dhcp6r -su fec0::204:ce33:763f:b34 -su fec0::504:ff33:73f:c557
+.fi
+Receive messages from clients at all IPv6
+interfaces by multicast and by unicast, and
+forward a copy of them to each of the specified
+addresses.
+.TP
+.SH dhcp6r -sm eth1 -su fec0::204:ce33:763f:b34
+Receive messages from clients at all IPv6
+interfaces by multicast and by unicast, and
+forward them to interface eth1 by multicast
+and to the specified unicast address.
+.TP            
+.SH dhcp6r -sm eth1 -sf eth0+fec0::504:ff33:73f:c557
+Receive messages from clients at all IPv6
+interfaces by multicast and by unicast, and
+forward them to interface eth1 by multicast 
+and to the specified unicast address.  For the 
+unicast address it is enforced that the message 
+will be sent through interface eth0.
+.SH NOTES            
+For proper operation of dhcp6r, the host must have at 
+least one global/site scope address assigned to each interface.
+.SH FILES
+.B       /var/log/dhcv6r.log
+.br
+.B       /var/run/dhcp6r.pid
+.br
+.SH BUGS
+Email bug reports to <bug@dhcpv6.org>
+.SH AUTHORS
+Cristian Cadar, <cadar@ccrle.nec.de>
+.br
+Juergen Quittek,
+.br
+Martin Stiemerling
--- /dev/null	2007-02-06 10:40:24.955607220 -0500
+++ dhcp-0.10/dhcp6r.c	2007-02-09 00:16:08.000000000 -0500
@@ -0,0 +1,354 @@
+/*
+ * Copyright (C) NEC Europe Ltd., 2003
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <stdlib.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <signal.h>
+#include <string.h>
+#if TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <sys/timeb.h>
+# include <time.h>
+#else
+# if HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#  include <time.h>
+# endif
+#endif
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include "relay6_parser.h"
+#include "relay6_socket.h"
+#include "relay6_database.h"
+
+int 
+main(argc, argv)
+	int argc;
+	char **argv;
+{
+	int err =0, i;
+	FILE *fp;
+	int sw = 0;
+	int du = 0;
+	struct interface *iface;
+	struct sockaddr_in6 sin6; 
+	char *sf, *eth, *addr;
+	struct cifaces *ci;
+	struct sifaces *si;
+	struct IPv6_uniaddr *unia;
+	struct server *sa;
+	struct msg_parser *mesg;
+
+	fp = fopen(PIDFILE, "w+");
+	if (fp == NULL) {
+		printf("COULD NOT WRITE PID FILE\n");
+		exit(1);
+	}
+	fprintf(fp, "%d", getpid());
+	fclose(fp);
+
+	signal(SIGINT, handler);
+	init_relay();
+
+	if (argc > 1) {
+		for (i = 1; i < argc; ++i) {
+			if (strcmp(argv[i], "-d") == 0)
+				du = 1;
+		}
+		if (du == 0) {        
+			dump = fopen(DUMPFILE, "w+");
+			if (dump == NULL) {
+				printf("COULD NOT WRITE DUMP FILE: %s\n", DUMPFILE);
+				exit(1);
+			}               
+    	}
+		else {
+			dump = stderr;
+    	}
+
+		if (get_interface_info() == 0)
+			goto ERROR;
+     
+		for(i = 1; i < argc; ++i) {     	
+			if (strcmp(argv[i], "-cm") == 0) {
+				i++;
+				if (get_interface_s(argv[i]) == NULL) {
+					err = 5;
+					goto ERROR;	
+				}     
+
+				sw = 1;
+				ci = (struct cifaces *) malloc(sizeof(struct cifaces));
+				if (ci == NULL) {
+					TRACE(dump, "%s - %s ", dhcp6r_clock(),  
+					      "Main--> ERROR NO MORE MEMORY AVAILABLE\n");
+					exit(1);
+				}
+				ci->ciface = strdup(argv[i]);
+				ci->next = cifaces_list.next;
+				cifaces_list.next = ci;	
+          	
+				TRACE(dump, "%s - %s'%s'\n", dhcp6r_clock(), 
+				      "SETTING UP CLIENT INTERFACE: ", argv[i]);
+				continue;  	
+			}
+			else if (strcmp(argv[i], "-cu") == 0) {
+				multicast_off = 1;          		         		
+			}
+			else if (strcmp(argv[i], "-sm") == 0) {
+          		i++;
+          		if (get_interface_s(argv[i]) == NULL) {
+					err = 5;
+					goto ERROR;	
+          		} 
+				si = (struct sifaces *) malloc(sizeof(struct sifaces));
+				if (si == NULL) {
+					TRACE(dump, "%s - %s", dhcp6r_clock(), 
+					      "Main--> ERROR NO MORE MEMORY AVAILABLE\n");
+					exit(1);
+				}
+				si->siface = strdup(argv[i]);
+				si->next = sifaces_list.next;
+				sifaces_list.next = si;	
+          	
+				TRACE(dump, "%s - %s'%s'\n", dhcp6r_clock(), 
+				      "SETTING UP SERVER INTERFACE: ", argv[i]);         	    
+          	
+				continue;
+			}
+			else if (strcmp(argv[i], "-d") == 0) {
+				continue; 
+			}
+			else if (strcmp(argv[i], "-su") == 0) {	
+				i++;
+				/* destination address */
+				if (inet_pton(AF_INET6, argv[i] , &sin6.sin6_addr) <= 0) { 
+					err = 3;
+					goto ERROR;	
+				}   
+          	               
+				if (IN6_IS_ADDR_UNSPECIFIED(&sin6.sin6_addr)) {
+					err = 3;
+					goto ERROR;
+				} 
+          	
+				unia = (struct IPv6_uniaddr *) 
+				       malloc(sizeof(struct IPv6_uniaddr));
+				if (unia == NULL) {
+					TRACE(dump, "%s - %s", dhcp6r_clock(), 
+				      	"Main--> ERROR NO MORE MEMORY AVAILABLE\n");
+   	            	exit(1);
+				}
+				unia->uniaddr = strdup(argv[i]);
+				unia->next = IPv6_uniaddr_list.next;
+				IPv6_uniaddr_list.next = unia;	
+          	
+				TRACE(dump, "%s - %s'%s'\n", dhcp6r_clock(),
+				      "SETTING UP SERVER ADDRESS: ", argv[i]); 
+				nr_of_uni_addr += 1;    
+
+          		continue;  		  
+			}
+			else if (strcmp(argv[i], "-sf") == 0) {
+				i++;
+				sf = strdup(argv[i]);
+
+				eth = strtok(sf, "+");
+				if (eth == NULL) {
+					err = 4;
+					goto ERROR;
+				}
+				addr = strtok((sf+strlen(eth)+1), "\0");
+				if (addr == NULL) {
+					err = 4;
+					goto ERROR;
+				}               
+              
+			 	/* destination address	*/
+				if (inet_pton(AF_INET6, addr , &sin6.sin6_addr) <= 0) { 
+					err = 3;
+					goto ERROR;
+				}
+
+				if (IN6_IS_ADDR_UNSPECIFIED(&sin6.sin6_addr) ) {
+					err = 3;
+					goto ERROR;
+				}
+
+				if ((iface = get_interface_s(eth)) != NULL) {
+					sa = (struct server *) malloc(sizeof(struct server));
+					if (sa == NULL) {
+						TRACE(dump, "%s - %s", dhcp6r_clock(), 
+						      "Main--> ERROR NO MORE MEMORY AVAILABLE\n");
+						exit(1);
+					}
+					sa->serv = strdup(addr);
+					sa->next = NULL;
+					if (iface->sname != NULL)
+						sa->next = iface->sname;                   
+					iface->sname = sa;                                                       
+					TRACE(dump, "%s - %s%s FOR INTERFACE: %s\n", dhcp6r_clock(),
+					      "SETTING UP SERVER ADDRESS: ", addr, eth);
+					free(sf);
+				}
+				else {
+					err = 5;
+					goto ERROR;
+				}
+
+				continue;
+			}
+			else if ((strcmp(argv[i], "-h") == 0) || 
+			         (strcmp(argv[i], "--help") == 0)) {
+				command_text();
+			}
+			else {
+				err = 4;
+				goto ERROR;	  
+			}
+		}
+	}
+	else {
+		dump = fopen(DUMPFILE, "w+");
+		if (dump == NULL) {
+			printf("COULD NOT WRITE DUMP FILE: %s\n", DUMPFILE);
+			exit(1);
+		}  
+             
+		if (get_interface_info() == 0)
+			goto ERROR;
+	}
+
+	if (sw == 1)
+		multicast_off = 0;   
+     
+	init_socket();
+  
+	if (set_sock_opt() == 0)
+		goto ERROR;
+
+	if (fill_addr_struct() == 0)
+		goto ERROR;
+
+	if (du == 0) {
+		switch(fork()) {
+			case 0:
+				break;
+			case -1:
+				perror("fork");
+				exit(1);
+			default:
+				exit(0);
+		} 
+	}
+
+	while (1) {
+		if (check_select() == 1) {
+			if (recv_data() == 1) {
+				if (get_recv_data() == 1) {
+					mesg = create_parser_obj();                  
+					if (put_msg_in_store (mesg) == 0)
+						mesg->sent = 1; /* mark it for deletion */
+				}
+			}
+		}
+	
+		send_message();
+		delete_messages();
+	}
+
+ERROR:
+	
+	if (err == 3) {
+		printf("dhcp6r: malformed address '%s'\n", argv[i]); 
+		exit(1);
+	} 	
+
+	if (err == 4) {
+		printf("dhcp6r: option '%s' not recognized\n", argv[i]); 
+		exit(1);
+	} 	
+ 
+	if (err == 5) {
+		printf("dhcp6r: interface '%s' does not exist \n", argv[i]);
+		exit(1);
+	}
+ 
+	printf("ERROR OCCURED IN THE RELAY AGENT LOOP, EXITING..........\n");
+	exit(1);
+}
+
+void 
+command_text() 
+{
+	printf("Usage:\n");
+	printf("       dhcp6r [-d] [-cu] [-cm <interface>] [-sm <interface>] "
+	       "[-su <address>] [-sf <interface>+<address>] \n");
+	exit(1);
+}
+
+char*  
+dhcp6r_clock() 
+{
+	time_t tim;
+	char *s, *p;
+
+	time(&tim);
+	s = ctime(&tim);
+  
+	p = s;
+	do {
+		p = strstr(p, " ");
+		if (p != NULL) {
+			if (*(p-1) == '/')
+				*p = '0';
+			else
+				*p = '/';
+		}
+	} while(p != NULL);  
+  
+	p = strstr(s, "\n");
+	if (p != NULL)
+		*p = '\0';
+  
+	return s;
+}
+
+void  handler(int signo) {
+	close(recvsock->recv_sock_desc);
+	close(sendsock->send_sock_desc);
+	TRACE(dump, "%s - %s", dhcp6r_clock(), 
+	      "RELAY AGENT IS STOPPING............\n");  
+	fflush(dump);
+
+	exit(0);
+}
--- /dev/null	2007-02-06 10:40:24.955607220 -0500
+++ dhcp-0.10/dhcp6r.h	2007-02-09 00:16:08.000000000 -0500
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) NEC Europe Ltd., 2003
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef __DHCP6R_H_DEFINED
+#define __DHCP6R_H_DEFINED
+
+#include <stdio.h>
+#include <stdint.h>
+
+#define MAX_DHCP_MSG_LENGTH     1400
+#define MESSAGE_HEADER_LENGTH   4
+#define ALL_DHCP_SERVERS           "FF05::1:3"
+#define ALL_DHCP_RELAY_AND_SERVERS "FF02::1:2"
+#define INET6_LEN               16
+#define OPAQ                    5000   //opaq value for interface id
+#define HEAD_SIZE               400
+#define HOP_COUNT_LIMIT         30
+#define DUMPFILE                "/var/log/dhcp6r.log"
+#define INTERFACEINFO           "/proc/net/if_inet6"
+#define PIDFILE                 "/var/run/dhcp6r.pid"
+#define MAXHOPCOUNT             32
+#define SERVER_PORT             547
+#define CLIENT_PORT             546
+#define TRACE                   fprintf
+  
+#define SOLICIT				1
+#define ADVERTISE			2
+#define REQUEST				3
+#define CONFIRM				4
+#define RENEW				5
+#define REBIND				6
+#define REPLY				7
+#define RELEASE				8
+#define DECLINE				9
+#define RECONFIGURE			10
+#define INFORMATION_REQUEST	11
+#define RELAY_FORW			12
+#define RELAY_REPL			13
+
+#define OPTION_RELAY_MSG	9
+#define OPTION_INTERFACE_ID	18
+
+char *dhcp6r_clock __P((void));
+FILE  *dump;
+void  handler __P((int signo));
+
+
+#endif /* __DHCP6R_H_DEFINED */
--- /dev/null	2007-02-06 10:40:24.955607220 -0500
+++ dhcp-0.10/dhcp6r.sh	2007-02-09 00:16:08.000000000 -0500
@@ -0,0 +1,89 @@
+#!/bin/sh
+#
+# dhcp6r        dhcp6r is an implementation of DHCPv6 relay agent.
+#               This shell script takes care of starting and stopping
+#               dhcp6r.
+#
+# chkconfig: - 66 36
+# description: dhcp6r supports the DHCPv6 relay agent protocol. 
+#            
+# processname: dhcp6r
+# config: /etc/sysconfig/dhcp6r
+
+# Source function library.
+. /etc/rc.d/init.d/functions
+
+# Source networking configuration.
+. /etc/sysconfig/network
+. /etc/sysconfig/dhcp6r
+
+# Check that networking is up.
+# networking is not up, return 1 for generic error
+[ ${NETWORKING} = "no" ] && exit 1
+
+# Check that files exist
+# return 5 if program is not installed
+[ -f /usr/sbin/dhcp6r ] || exit 5
+
+# return 6 if program is not configured
+[ -f /etc/sysconfig/dhcp6r ] || exit 6
+
+RETVAL=0
+prog="dhcp6r"
+
+start() {
+	# Start daemons.
+	echo -n $"Starting $prog: "
+	daemon /usr/sbin/dhcp6r ${DHCP6RARGS}
+	RETVAL=$?
+	echo
+	[ $RETVAL -eq 0 ] && touch /var/lock/subsys/dhcp6r
+	return $RETVAL
+}
+
+stop() {
+	# Stop daemons.
+	echo -n $"Shutting down $prog: "
+	killproc dhcp6r
+	RETVAL=$?
+	echo
+	[ $RETVAL -eq 0 ] && rm -f /var/lock/subsys/dhcp6r
+	return $RETVAL
+}
+
+# See how we were called.
+case "$1" in
+  start)
+	start
+	RETVAL=$?
+	;;
+  stop)
+	stop
+	RETVAL=$?
+	;;
+  restart|force-reload)
+	stop
+	start
+	RETVAL=$?
+	;;
+  reload)
+	# unimplemented
+	RETVAL=3
+	;;
+  condrestart)
+	if [ -f /var/lock/subsys/dhcp6s ]; then
+	    stop
+	    start
+	    RETVAL=$?
+	fi
+	;;
+  status)
+	status dhcp6r
+	RETVAL=$?
+	;;
+  *)
+	echo $"Usage: $0 {start|stop|restart|condrestart|status}"
+	exit 1
+esac
+
+exit $RETVAL
--- /dev/null	2007-02-06 10:40:24.955607220 -0500
+++ dhcp-0.10/dhcp6r.sysconfig	2007-02-09 00:16:08.000000000 -0500
@@ -0,0 +1,3 @@
+# Configuration for the DHCPv6 relay agent, dhcp6r
+# Command line options here
+DHCP6RARGS=
--- /dev/null	2007-02-06 10:40:24.955607220 -0500
+++ dhcp-0.10/relay6_database.c	2007-02-09 00:47:58.000000000 -0500
@@ -0,0 +1,569 @@
+/*
+ * Copyright (C) NEC Europe Ltd., 2003
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include "relay6_database.h"
+
+void  
+init_relay() 
+{
+	nr_of_uni_addr = 0;	
+	multicast_off = 0;
+	nr_of_devices = 0;
+	max_count = 0;
+
+	cifaces_list.next = &cifaces_list;
+
+	sifaces_list.next = &sifaces_list;
+ 
+	server_list.next = &server_list;
+ 
+	IPv6_address_list.next = &IPv6_address_list;
+ 
+	IPv6_uniaddr_list.next = &IPv6_uniaddr_list;
+ 
+	interface_list.prev = &interface_list;	
+	interface_list.next = &interface_list;	
+
+	msg_parser_list.prev = &msg_parser_list;	
+	msg_parser_list.next = &msg_parser_list; 
+}
+
+int 
+check_interface_semafor(index)
+	int index;
+{
+	struct interface *device = NULL;
+	struct cifaces *iface;
+
+	device = get_interface(index);
+	if (device == NULL) {
+		printf("FATAL ERROR IN CheckInterfaceSemafor()\n");
+		exit(1);   	
+	}	
+     
+	if (cifaces_list.next == &cifaces_list)
+		return 1;
+          
+	for (iface = cifaces_list.next; iface != &cifaces_list; 
+	     iface = iface->next) {
+		if (strcmp(device->ifname, iface->ciface) == 0)
+			return 1;   		
+	}	
+ 
+	return 0;
+}	
+
+struct interface *
+get_interface(if_index)
+	int if_index;
+{
+	struct interface *deviface;
+ 
+	for (deviface = interface_list.next; deviface != &interface_list;  
+	     deviface = deviface->next) {
+		if (deviface->devindex == if_index)
+			return deviface;
+	}
+
+	return NULL;
+}
+
+struct interface *
+get_interface_s(s)
+	char *s;
+{
+	struct interface *deviface;
+
+	for (deviface = interface_list.next; deviface != &interface_list;  
+	     deviface = deviface->next) {   
+		if (strcmp(s, deviface->ifname)== 0)
+			return deviface;
+	}
+
+	return NULL;
+}
+
+struct msg_parser *
+get_send_messages_out()
+{
+	struct msg_parser *msg;
+
+	for (msg = msg_parser_list.next; msg != &msg_parser_list; msg = msg->next) {
+		if (msg->sent == 0)
+			return msg;
+	}
+         	         
+	return NULL;
+}
+
+
+void
+delete_messages()
+{
+	struct msg_parser *msg;
+
+	for (msg = msg_parser_list.next; msg != &msg_parser_list; msg = msg->next) {
+		if (msg->sent == 1) {
+			msg->prev->next = msg->next;
+			msg->next->prev = msg->prev;
+			msg->next = NULL;
+			msg->prev = NULL;
+			free(msg->buffer);            	 
+			free(msg);
+			msg = msg_parser_list.next;
+		}        	
+	}
+}
+
+
+int
+process_RELAY_FORW(msg)
+	struct msg_parser *msg;
+{
+	uint8_t *head = (uint8_t *) malloc(HEAD_SIZE*sizeof(uint8_t));
+	uint8_t *newbuff = (uint8_t *) malloc(MAX_DHCP_MSG_LENGTH*sizeof(uint8_t));
+	uint8_t *pointer;
+	struct interface *device = NULL;
+	struct sockaddr_in6 sap;
+	int check = 0;
+	uint16_t *p16, *optl;
+	uint32_t *p32;
+	int len, hop;
+
+	if ((head == NULL) || (newbuff == NULL)) {
+		printf("ProcessRELAYFORW--> ERROR, NO MORE MEMRY AVAILABLE  \n");	
+		exit(1);	
+	}	
+ 
+	memset(head, 0, HEAD_SIZE);
+
+	pointer = head;
+
+
+	if (msg->isRF == 1) { /* got message from a relay agent to be relayed */
+		(*pointer) = RELAY_FORW;
+		pointer += 1;
+		(*pointer) = msg->hop_count + 1; /* increased hop-count */
+		msg->hc_pointer = pointer;
+
+		if (max_count == 1) {
+			(*pointer) = MAXHOPCOUNT;
+			hop = (int) (*pointer);            
+			TRACE(dump, "%s - %s%d\n", dhcp6r_clock(), "HOPCOUNT: ", hop);
+		}
+
+		pointer += 1;
+
+	}
+	else {            /*got message from a client to be relayed */
+		(*pointer) = RELAY_FORW;
+		pointer += 1;
+		(*pointer) = 0; /* hop-count */
+		msg->hc_pointer = pointer;
+
+		if (max_count == 1) {
+			(*pointer) = MAXHOPCOUNT;
+			hop = (int) (*pointer);	            
+			TRACE(dump, "%s - %s%d\n", dhcp6r_clock(), "HOPCOUNT: ", hop);
+		}
+		pointer += 1;
+	}
+
+	msg->msg_type = RELAY_FORW;
+
+	device = get_interface(msg->interface_in);
+	if (device == NULL) {
+		printf("ProcessRELAYFORW--->ERROR NO INTERFACE FOUND!\n");
+		exit(1);
+	}
+
+	/* fill in link-address */
+
+	if (inet_pton(AF_INET6, msg->src_addr , &sap.sin6_addr) <= 0) {
+		printf("ProcessRELAYFORW1--->ERROR IN  inet_pton !\n");
+		exit(1);
+	}
+
+	if ((!IN6_IS_ADDR_LINKLOCAL(&sap.sin6_addr)) && (nr_of_devices == 1 )) {
+		memset(&sap.sin6_addr, 0, sizeof(sap.sin6_addr));
+		memcpy(pointer, &sap.sin6_addr, INET6_LEN);
+		pointer += INET6_LEN;
+	}
+	else {
+		check = 0;
+          
+		memset(&sap.sin6_addr, 0, sizeof(sap.sin6_addr));
+
+		if (inet_pton(AF_INET6, device->ipv6addr->gaddr, &sap.sin6_addr) <= 0) {
+			printf("ProcessRELAYFORW1--->ERROR IN  inet_pton !\n");
+			exit(1);
+		}
+
+		memcpy(pointer, &sap.sin6_addr, INET6_LEN);
+		pointer += INET6_LEN;
+	}
+
+
+	/* fill in peer-addrees */
+	memset(&sap.sin6_addr, 0, sizeof(sap.sin6_addr));
+
+	if (inet_pton(AF_INET6, msg->src_addr , &sap.sin6_addr) <= 0) {
+		printf("ProcessRELAYFORW--->ERROR2 IN  inet_pton !\n");
+		exit(1);
+	}
+
+	memcpy(pointer, &sap.sin6_addr, INET6_LEN);
+	pointer += INET6_LEN;
+
+	/* Insert Interface_ID option to identify the interface */
+	p16 = (uint16_t *) pointer;
+	*p16 = htons(OPTION_INTERFACE_ID);
+	pointer += 2;
+	p16 = (uint16_t *) pointer;
+	*p16 = htons(4); /* 4 octeti length */
+	pointer += 2;
+	p32 = (uint32_t *) pointer;
+	*p32 = htonl(device->opaq);
+	pointer += 4;
+
+	p16 = (uint16_t *) pointer;
+	*p16 = htons(OPTION_RELAY_MSG);
+	pointer += 2;
+	optl = (uint16_t *) pointer;
+	pointer += 2;
+	*optl = htons(msg->datalength);
+
+	len = (pointer - head);
+	TRACE(dump, "%s - %s%d\n", dhcp6r_clock(), "RELAY_FORW HEADERLENGTH: ", 
+	      len);
+	TRACE(dump, "%s - %s%d\n", dhcp6r_clock(), "ORIGINAL MESSAGE LENGTH: ",
+	      msg->datalength );
+	
+	if ((len+ msg->datalength) > MAX_DHCP_MSG_LENGTH) {
+		printf(" ERROR FRAGMENTATION WILL OCCUR IF SENT, DROP THE PACKET"
+		       "......\n");
+		return 0;
+	}
+
+	pointer = newbuff;
+	memset(pointer, 0, MAX_DHCP_MSG_LENGTH);
+	memcpy(pointer, head, len);
+	pointer += len;
+	memcpy(pointer, msg->buffer, msg->datalength);
+	msg->datalength += len; /* final length for sending */
+	free(msg->buffer);
+	free(head);
+	msg->buffer = newbuff;
+
+	return 1;
+}
+
+int 
+process_RELAY_REPL(msg)
+	struct msg_parser *msg;
+{
+	uint8_t *newbuff = (uint8_t *) malloc(MAX_DHCP_MSG_LENGTH*sizeof(uint8_t)); 
+	uint8_t *pointer, *pstart, *psp;
+	struct interface *device = NULL;
+	struct sockaddr_in6 sap;
+	int check = 0;
+	uint16_t *p16, option, opaqlen, msglen;
+	uint32_t *p32;
+	int len, opaq;
+	struct IPv6_address *ipv6a;
+	char *s; 
+ 
+	if (newbuff == NULL) {
+		printf("ProcessRELAYREPL--> ERROR, NO MORE MEMRY AVAILABLE  \n");	
+		exit(1);	
+	}
+
+	pointer = msg->buffer;
+	pstart = pointer;
+
+	if ((*msg->buffer - (*pointer - *pstart)) < MESSAGE_HEADER_LENGTH) {
+		printf("ProcessRELAYREPL()--> opt_length has 0 value for "
+		       "MESSAGE_HEADER_LENGTH, DROPING... \n");
+		return 0;
+	}
+
+	if (*pointer != RELAY_REPL)
+		return 0;
+
+	pointer += 1;  /* RELAY_FORW */
+	msg->hop = *pointer;
+	pointer += 1;    /* hop-count */
+	msg->msg_type = RELAY_REPL;
+
+	if ((*msg->buffer - (*pointer - *pstart)) < (2*INET6_LEN) ) {
+		printf("ProcessRELAYREPL()--> opt_length has 0 value for "
+		       "INET6_LEN, DROPING... \n");
+		return 0;
+	}
+
+	/* extract link_address */
+	memset(msg->link_addr, 0, INET6_ADDRSTRLEN);
+	memset(&sap.sin6_addr, 0, sizeof(sap.sin6_addr));
+	memcpy(&sap.sin6_addr, pointer, INET6_LEN);
+	pointer += INET6_LEN;
+
+	if (inet_ntop(AF_INET6, &sap.sin6_addr, msg->link_addr, 
+	              INET6_ADDRSTRLEN ) <=0 ) {
+		printf("ProcessRELAYREPL1--->ERROR IN inet_ntop  !\n");
+		exit(1);
+	}
+
+	/* extract peer address */
+	memset(msg->peer_addr, 0, INET6_ADDRSTRLEN);
+	memset(&sap.sin6_addr, 0, sizeof(sap.sin6_addr));
+	memcpy(&sap.sin6_addr, pointer, INET6_LEN);
+	pointer += INET6_LEN;
+
+	if (inet_ntop(AF_INET6, &sap.sin6_addr, msg->peer_addr, 
+	              INET6_ADDRSTRLEN ) <=0 ) {         
+		printf("ProcessRELAYREPL1--->ERROR IN inet_ntop  !\n");
+		exit(1);
+	}
+
+	if ((*msg->buffer - (*pointer - *pstart)) < MESSAGE_HEADER_LENGTH ) {
+		printf("ProcessRELAYREPL()--> opt_length has 0 value for "
+		       "MESSAGE_HEADER_LENGTH, DROPING... \n");
+		return 0;
+	}
+
+	p16 = (uint16_t *) pointer;
+	option = ntohs(*p16);
+
+	if (option == OPTION_INTERFACE_ID) {
+		pointer += 2;
+		p16 = (uint16_t *) pointer;
+		opaqlen = ntohs(*p16);
+		pointer += 2;
+
+		if ((*msg->buffer - (*pointer - *pstart)) <  opaqlen) {
+			printf("ProcessRELAYREPL()--> opt_length has 0 value for "
+			       "opaqlen, DROPING... \n");
+			return 0;
+		}
+
+		p32 = (uint32_t *) pointer;
+		opaq = ntohl(*p32);
+		pointer += opaqlen;
+
+		if ((*msg->buffer - (*pointer - *pstart)) < MESSAGE_HEADER_LENGTH ) {
+			printf("ProcessRELAYREPL()--> opt_length has 0 value for "
+			       "MESSAGE_HEADER_LENGTH, DROPING... \n");
+			return 0;
+		}
+
+		p16 = (uint16_t *) pointer;
+		option = ntohs(*p16);
+
+		if (option == OPTION_RELAY_MSG) {
+			pointer += 2;
+			p16 = (uint16_t *) pointer;
+			msglen = ntohs(*p16);
+			pointer += 2;
+			if ((*msg->buffer - (*pointer - *pstart)) < msglen) {
+				printf("ProcessRELAYREPL()--> opt_length has 0 value for "
+				       "msglen, DROPING... \n");
+				return 0;
+			}
+              
+			/*--------------------------*/
+			if (*pointer == RELAY_FORW)
+				*pointer = RELAY_REPL; /* is the job of the server to set to 
+				                         RELAY_REPL? */
+			/*--------------------------*/
+			for (device = interface_list.next; device != &interface_list;  
+			     device = device->next) {
+				if (device->opaq == opaq)
+					break;
+			}
+
+			if (device != &interface_list ) {
+				msg->if_index = device->devindex;
+				memset(newbuff, 0, MAX_DHCP_MSG_LENGTH);
+				len = (pointer - msg->buffer);
+				len = (msg->datalength - len);
+				memcpy(newbuff, pointer, len);
+				msg->datalength = len;
+				free(msg->buffer);
+				msg->buffer = newbuff;
+				return 1;
+				
+			}
+			else {
+				s = msg->link_addr;
+                    
+				for (device = interface_list.next; device != &interface_list;  
+				     device = device->next) {
+					ipv6a = device->ipv6addr;
+
+					while(ipv6a!= NULL) { 
+						if (strcmp(s, ipv6a->gaddr) == 0) {
+							msg->if_index = device->devindex;
+							check = 1;
+							break;
+						}
+						ipv6a = ipv6a->next;
+					}
+
+					if (check == 1) 
+						break;
+				}
+
+				if (check == 0) {
+					printf("ProcessRELAYREPL--->ERROR NO INTERFACE FOUND!\n");
+					return 0;
+				}
+
+				memset(newbuff, 0, MAX_DHCP_MSG_LENGTH);
+				len = (pointer - msg->buffer);
+				len = (msg->datalength - len);
+				memcpy(newbuff, pointer, len);
+				msg->datalength = len;
+				free(msg->buffer);
+				msg->buffer = newbuff;
+				return 1;	       
+			}
+		}
+		else { /* OPTION_RELAY_MSG */
+			printf("ProcessRELAYREPL--->ERROR MESSAGE IS MALFORMED NO "
+			       "OPTION_RELAY_MSG FOUND, DROPING...!\n");
+			return 0;
+		}
+	} /* OPTION_INTERFACE_ID */
+
+	if (option == OPTION_RELAY_MSG) {
+		pointer += 2;
+		p16 = (uint16_t *) pointer;
+		msglen = ntohs(*p16);
+		pointer += 2;
+
+		if ((*msg->buffer - (*pointer - *pstart)) < msglen ) {
+			printf("ProcessRELAYREPL()--> opt_length has 0 value for "
+			       "msglen, DROPING... \n");
+			return 0;
+		}
+
+		opaq = 0;
+		psp = (pointer + msglen); /* jump over message, seek for 
+		                              OPTION_INTERFACE_ID */
+
+		if ((*msg->buffer - (*psp - *pstart)) >= MESSAGE_HEADER_LENGTH ) {
+			if (option == OPTION_INTERFACE_ID) {
+				psp += 2;
+				p16 = (uint16_t *) psp;
+				opaqlen = ntohs(*p16);
+				psp += 2;
+
+				if ((*msg->buffer - (*psp - *pstart)) <  opaqlen) {
+					printf("ProcessRELAYREPL()--> opt_length has 0 value "
+					       "for opaqlen, DROPING... \n");
+					return 0;
+				}
+
+				p32 = (uint32_t *) psp;
+				opaq = ntohl(*p32);
+				psp += opaqlen;
+			}
+		}
+
+		/*--------------------------*/
+		if (*pointer == RELAY_FORW)
+			*pointer = RELAY_REPL; /* is the job of the server to set to 
+		                          RELAY_REPL? */
+		/*--------------------------*/
+		for (device = interface_list.next; device != &interface_list;
+		     device = device->next) {             
+			if (device->opaq == opaq)
+				break;
+		}
+
+		if (device != &interface_list) {
+			msg->if_index = device->devindex;
+			memset(newbuff, 0, MAX_DHCP_MSG_LENGTH);
+			len = (pointer - msg->buffer);
+			len = (msg->datalength - len);
+			memcpy(newbuff, pointer, len);
+			msg->datalength = len;
+			free(msg->buffer);
+			msg->buffer = newbuff;
+			return 1;
+		}
+		else {
+			s = msg->link_addr;
+	
+			for (device = interface_list.next; device != &interface_list;
+		     	device = device->next) {
+				ipv6a = device->ipv6addr;
+                   	  	
+				while(ipv6a != NULL) { 
+					if (strcmp(s, ipv6a->gaddr) == 0) {
+						msg->if_index = device->devindex;
+						check = 1;
+						break;
+					}
+					ipv6a = ipv6a->next;
+				}
+
+				if (check == 1) 
+					break;
+			}
+  
+			if (check == 0) {
+				printf("ProcessRELAYREPL--->ERROR NO INTERFACE FOUND!\n");
+				return 0;
+			}
+
+			memset(newbuff, 0, MAX_DHCP_MSG_LENGTH);
+			len = (pointer - msg->buffer);
+			len = (msg->datalength - len);
+			memcpy(newbuff, pointer, len);
+			msg->datalength = len;
+			free(msg->buffer);
+			msg->buffer = newbuff;
+			return 1;
+		}
+	}
+	else { /* OPTION_RELAY_MSG */
+		printf("ProcessRELAYREPL--->ERROR MESSAGE IS MALFORMED NO "
+		       "OPTION_RELAY_MSG FOUND, DROPING...!\n");
+		return 0;
+	}
+
+	return 1;
+}
--- /dev/null	2007-02-06 10:40:24.955607220 -0500
+++ dhcp-0.10/relay6_database.h	2007-02-09 00:16:08.000000000 -0500
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) NEC Europe Ltd., 2003
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef __RELAY6_DATABASE_H_DEFINED
+#define __RELAY6_DATABASE_H_DEFINED
+
+#include "dhcp6r.h"
+#include "relay6_parser.h"
+
+struct cifaces {
+	struct cifaces *next;
+	char *ciface;
+};
+
+struct sifaces {
+	struct sifaces *next;
+	char *siface;
+};
+
+struct server {
+	struct server *next;
+	char *serv;
+};
+
+struct IPv6_address {
+	struct IPv6_address *next;
+	char *gaddr;
+};
+
+struct IPv6_uniaddr { /* STORAGE OF UNICAST  DEST. SERVER ADRESSES */
+	struct IPv6_uniaddr *next;
+	char *uniaddr;
+};
+
+struct interface {
+	struct interface *next;
+	struct interface *prev;  
+
+	struct server *sname; 
+	struct IPv6_address *ipv6addr;
+     
+	int got_addr;
+	char *ifname;
+	uint32_t devindex;
+	char *link_local;
+	int opaq;  
+};
+
+struct cifaces cifaces_list;
+struct sifaces sifaces_list;
+struct server  server_list;
+struct IPv6_address IPv6_address_list;
+struct IPv6_uniaddr IPv6_uniaddr_list;
+struct interface    interface_list ;
+
+int process_RELAY_FORW __P((struct msg_parser *msg));
+int process_RELAY_REPL __P((struct msg_parser *msg));
+struct msg_parser *get_send_messages_out __P((void));
+void delete_messages __P((void));
+int check_interface_semafor __P((int index));
+struct interface *get_interface __P((int if_index));
+struct interface *get_interface_s __P((char *s));
+ 
+int nr_of_devices;
+int nr_of_uni_addr;
+int max_count;
+int multicast_off;
+
+void init_relay __P((void));
+void command_text __P((void));
+
+#endif /* __RELAY6_DATABASE_H_DEFINED */
--- /dev/null	2007-02-06 10:40:24.955607220 -0500
+++ dhcp-0.10/relay6_parser.c	2007-02-09 00:16:08.000000000 -0500
@@ -0,0 +1,278 @@
+/*
+ * Copyright (C) NEC Europe Ltd., 2003
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "relay6_parser.h"
+#include "relay6_database.h"
+
+struct msg_parser *create_parser_obj() 
+{
+	struct msg_parser *msg;
+  
+	msg = (struct msg_parser *) malloc (sizeof(struct msg_parser));
+	if (msg == NULL) {
+		printf("create_parser_obj()--> NO MORE MEMORY AVAILABLE\n"); 
+		exit(1);
+	}  
+  
+	msg->buffer = (uint8_t *) malloc(MAX_DHCP_MSG_LENGTH*sizeof(uint8_t));
+	if (msg->buffer == NULL) {
+		printf("create_parser_obj()--> NO MORE MEMORY AVAILABLE\n"); 
+		exit(1);
+	}
+
+	memcpy(msg->buffer, recvsock->databuf, MAX_DHCP_MSG_LENGTH);
+
+	msg->sent = 0;
+	msg->if_index = 0;
+
+	msg->interface_in = recvsock->pkt_interface;
+	memcpy(msg->src_addr, recvsock->src_addr, sizeof(recvsock->src_addr));
+	msg->datalength = recvsock->buflength;
+	msg->pointer_start = msg->buffer;
+	msg->dst_addr_type = recvsock->dst_addr_type;
+  
+	msg->prev = &msg_parser_list;
+	msg->next =  msg_parser_list.next;
+	msg->prev->next = msg;
+	msg->next->prev = msg;
+   
+	TRACE(dump, "\n%s - RECEIVED NEW MESSAGE ON INTERFACE: %d,  SOURCE: %s\n",
+	      dhcp6r_clock(), msg->interface_in, msg->src_addr);
+ 
+	return msg;
+}
+
+int
+check_buffer(ref, mesg) 
+	int ref;
+	struct msg_parser *mesg;
+{
+	int diff;
+	diff =(int) (mesg->pstart - mesg->pointer_start);
+     
+	if ((((int) mesg->datalength) - diff) >= ref)
+		return 1;
+	else
+		return 0;
+}
+
+int
+put_msg_in_store(mesg) 
+	struct msg_parser *mesg;
+{
+	uint32_t msg_type;
+	uint8_t *hop, msg;
+
+	/* --------------------------- */
+	mesg->pstart = mesg->buffer;
+    
+	if (check_buffer(MESSAGE_HEADER_LENGTH, mesg) == 0) {
+		printf("put_msg_in_store()--> opt_length has 0 value for "
+		       "MESSAGE_HEADER_LENGTH, DROPING... \n");
+		return 0;
+	}
+	msg_type = *((uint32_t *) mesg->pstart);
+	msg_type =  (ntohl(msg_type) & 0xFF000000)>>24;
+
+	if (msg_type == SOLICIT) {
+		if (check_interface_semafor(mesg->interface_in) == 0)
+			return 0;
+		TRACE(dump, "%s - %s", dhcp6r_clock(),
+		      "GOT MESSAGE 'SOLICIT' FROM CLIENT---> IS TO BE RELAYED\n");
+		mesg->isRF = 0;
+		if (process_RELAY_FORW(mesg) == 0)
+			return 0;
+
+		return 1;
+	}
+	else if (msg_type == REBIND) {
+		if (check_interface_semafor(mesg->interface_in) == 0)
+			return 0;  
+                
+		TRACE(dump, "%s - %s", dhcp6r_clock(),
+		      "GOT MESSAGE 'REBIND' FROM CLIENT---> IS TO BE RELAYED\n");
+		mesg->isRF = 0;
+		if (process_RELAY_FORW(mesg) == 0)
+			return 0;
+
+		return 1;
+	}
+	else if (msg_type == INFORMATION_REQUEST) {
+		if (check_interface_semafor(mesg->interface_in) == 0)
+			return 0;
+         
+		TRACE(dump, "%s - %s", dhcp6r_clock(),
+		      "GOT MESSAGE 'INFORMATION_REQUEST' FROM CLIENT---> "
+		      "IS TO BE RELAYED\n");
+		mesg->isRF = 0;
+		if (process_RELAY_FORW(mesg) == 0)
+			return 0;
+
+		return 1;
+	}
+	else if (msg_type == REQUEST) {
+		if (check_interface_semafor(mesg->interface_in) == 0)
+			return 0;
+         
+		TRACE(dump, "%s - %s", dhcp6r_clock(), 
+		      "GOT MESSAGE 'REQUEST' FROM CLIENT---> IS TO BE RELAYED\n");
+		mesg->isRF = 0;
+		if (process_RELAY_FORW(mesg) == 0)
+			return 0;
+
+		return 1;
+	}
+	else if (msg_type == REPLY) {
+		if (check_interface_semafor(mesg->interface_in) == 0)
+			return 0;
+         
+		TRACE(dump, "%s - %s", dhcp6r_clock(),
+		      "GOT MESSAGE 'REPLY' FROM CLIENT---> IS TO BE RELAYED\n");
+		mesg->isRF = 0;
+		if (process_RELAY_FORW(mesg) == 0)
+			return 0;
+
+		return 1;
+	}
+	else if (msg_type == RENEW) {
+		if (check_interface_semafor(mesg->interface_in) == 0)
+			return 0;
+         
+		TRACE(dump, "%s - %s", dhcp6r_clock(),
+		      "GOT MESSAGE 'RENEW' FROM CLIENT---> IS TO BE RELAYED\n");
+		mesg->isRF = 0;
+		if (process_RELAY_FORW(mesg) == 0)
+			return 0;
+
+		return 1;
+	}
+	else if (msg_type == RECONFIGURE) {
+		if (check_interface_semafor(mesg->interface_in) == 0)
+			return 0;
+         
+		TRACE(dump, "%s - %s", dhcp6r_clock(),
+		      "GOT MESSAGE 'RECONFIGURE' FROM CLIENT---> IS TO BE RELAYED\n");
+		mesg->isRF = 0;
+		if (process_RELAY_FORW(mesg) == 0)
+			return 0;
+
+		return 1;
+	} 
+	else if (msg_type == CONFIRM) {
+		if (check_interface_semafor(mesg->interface_in) == 0)
+			return 0;
+         
+		TRACE(dump, "%s - %s", dhcp6r_clock(),
+		      "GOT MESSAGE 'CONFIRM' FROM CLIENT---> IS TO BE RELAYED\n");
+		mesg->isRF = 0;
+		if (process_RELAY_FORW(mesg) == 0)
+			return 0;
+
+		return 1;
+	}
+	else if (msg_type == ADVERTISE) {
+		if (check_interface_semafor(mesg->interface_in) == 0)
+			return 0;
+         
+		TRACE(dump, "%s - %s", dhcp6r_clock(),
+		      "GOT MESSAGE 'ADVERTISE' FROM CLIENT---> IS TO BE RELAYED\n");
+		mesg->isRF = 0;
+		if (process_RELAY_FORW(mesg) == 0)
+			return 0;
+
+		return 1;
+	} 
+	else if (msg_type == DECLINE) {
+		if (check_interface_semafor(mesg->interface_in) == 0)
+			return 0;
+         
+		TRACE(dump, "%s - %s", dhcp6r_clock(),
+		      "GOT MESSAGE 'DECLINE' FROM CLIENT---> IS TO BE RELAYED\n");
+		mesg->isRF = 0;
+		if (process_RELAY_FORW(mesg) == 0)
+			return 0;
+
+		return 1;
+	}
+	else if (msg_type == RELEASE) {
+		if (check_interface_semafor(mesg->interface_in) == 0)
+			return 0;
+         
+		TRACE(dump, "%s - %s", dhcp6r_clock(),
+		      "GOT MESSAGE 'RELEASE' FROM CLIENT---> IS TO BE RELAYED\n");
+		mesg->isRF = 0;
+		if (process_RELAY_FORW(mesg) == 0)
+			return 0;
+
+		return 1;
+	}
+	msg = *mesg->pstart;
+ 
+	if (msg == RELAY_FORW) {
+		if (check_interface_semafor(mesg->interface_in) == 0)
+			return 0;
+         
+		TRACE(dump, "%s - %s", dhcp6r_clock(),
+		      "GOT MESSAGE 'RELAY_FORW' FROM RELAY AGENT---> "
+		      "IS TO BE FURTHER RELAYED\n");
+		hop = (mesg->pstart + 1);
+		if (*hop >= HOP_COUNT_LIMIT) {
+			TRACE(dump, "%s - %s", dhcp6r_clock(),
+			      "HOP COUNT EXCEEDED, PACKET WILL BE DROPED...\n");
+			return 0;
+		}
+
+		mesg->hop_count = *hop;
+		mesg->isRF = 1;
+
+		if (process_RELAY_FORW(mesg) == 0)
+			return 0;
+
+		return 1;
+	}
+
+	if (msg == RELAY_REPL) {
+		TRACE(dump, "%s - %s", dhcp6r_clock(), 
+		      "GOT MESSAGE 'RELAY_REPL' FROM RELAY AGENT OR SERVER---> "
+		      "IS TO BE FURTHER RELAYED\n");
+
+		if (process_RELAY_REPL(mesg) == 0)
+			return 0;
+       
+		return 1;
+	}
+
+	TRACE(dump, "%s - %s", dhcp6r_clock(),
+	      "put_msg_in_store()--> ERROR GOT UNKNOWN MESSAGE DROPING IT......\n");
+
+	return 0;
+}
--- /dev/null	2007-02-06 10:40:24.955607220 -0500
+++ dhcp-0.10/relay6_parser.h	2007-02-09 00:16:08.000000000 -0500
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) NEC Europe Ltd., 2003
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef __RELAY6_PARSER_H_DEFINED
+#define __RELAY6_PARSER_H_DEFINED
+
+#include "dhcp6r.h"
+#include "relay6_socket.h"
+
+struct msg_parser {
+	struct msg_parser *next;
+	struct msg_parser *prev;
+    
+	int if_index;
+	uint8_t msg_type;
+	uint8_t hop;
+	uint8_t *buffer;
+	uint8_t *ptomsg;
+	uint8_t *pstart, *pointer_start, *hc_pointer;
+	uint32_t datalength;  /* the length of the DHCPv6 message */
+	int dst_addr_type;
+	char src_addr[INET6_ADDRSTRLEN];  /* source address from the UDP packet */
+	char peer_addr[INET6_ADDRSTRLEN];
+	char link_addr[INET6_ADDRSTRLEN];
+	int interface_in, hop_count;
+	int sent;
+	int isRF;
+};
+
+struct msg_parser msg_parser_list;
+ 
+struct msg_parser *create_parser_obj __P((void));
+int put_msg_in_store __P((struct msg_parser *mesg));
+int check_buffer __P((int ref, struct msg_parser *mesg));
+
+#endif /* __RELAY6_PARSER_H_DEFINED */
--- /dev/null	2007-02-06 10:40:24.955607220 -0500
+++ dhcp-0.10/relay6_socket.c	2007-02-09 00:16:08.000000000 -0500
@@ -0,0 +1,802 @@
+/*
+ * Copyright (C) NEC Europe Ltd., 2003
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include <net/if.h>
+
+#include "relay6_socket.h"
+#include "relay6_database.h"
+
+void 
+init_socket()
+{
+	recvsock = (struct receive *) malloc(sizeof(struct receive));
+	sendsock = (struct send *) malloc(sizeof(struct send)); 
+   
+	if ((recvsock == NULL) || (sendsock == NULL)) {
+		TRACE(dump, "%s - %s", dhcp6r_clock(),
+		      "init_socket--> ERROR NO MORE MEMORY AVAILABLE\n");
+		exit(1);
+	}	
+
+	memset(recvsock, 0, sizeof(struct receive));
+	memset(sendsock, 0, sizeof(struct send));
+   
+	recvsock->databuf = (char *) malloc(MAX_DHCP_MSG_LENGTH*sizeof(char));
+	if (recvsock->databuf == NULL) {
+		TRACE(dump, "%s - %s", dhcp6r_clock(),
+		      "init_socket--> ERROR NO MORE MEMORY AVAILABLE\n");
+		exit(1);
+	}	  
+
+	if ((recvsock->recv_sock_desc = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
+		printf("Failed to get new socket with socket()\n");
+		exit(0);
+	}
+
+	if ((sendsock->send_sock_desc = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
+		printf("Failed to get new socket with socket()\n");
+		exit(0);
+	}
+}
+
+int
+get_recv_data() 
+{
+	struct cmsghdr *cm;
+	struct in6_pktinfo *pi;
+	struct sockaddr_in6 dst;
+
+	memset(recvsock->src_addr, 0, sizeof(recvsock->src_addr));
+
+	for(cm = (struct cmsghdr *) CMSG_FIRSTHDR(&recvsock->msg); cm; 
+	    cm = (struct cmsghdr *) CMSG_NXTHDR(&recvsock->msg, cm)) {
+		if ((cm->cmsg_level == IPPROTO_IPV6) && (cm->cmsg_type == IPV6_PKTINFO)
+		    && (cm->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo)))) {
+			pi = (struct in6_pktinfo *)(CMSG_DATA(cm));
+			dst.sin6_addr = pi->ipi6_addr;
+			recvsock->pkt_interface = pi->ipi6_ifindex; /* the interface index 
+			                                               the packet got in */
+
+			if (IN6_IS_ADDR_LOOPBACK(&recvsock->from.sin6_addr)) {
+				TRACE(dump, "%s - %s", dhcp6r_clock(), 
+				      "get_recv_data()-->SOURCE ADDRESS IS LOOPBACK!\n");
+				return 0;
+			}
+
+			if (inet_ntop(AF_INET6, &recvsock->from.sin6_addr, 
+			              recvsock->src_addr, INET6_ADDRSTRLEN) <= 0) {
+				TRACE(dump, "%s - %s", dhcp6r_clock(),
+				      "inet_ntop failed in get_recv_data()\n");
+				return 0;
+       		}
+
+			if (IN6_IS_ADDR_LOOPBACK(&dst.sin6_addr)) {
+				recvsock->dst_addr_type = 1;
+			}
+			else if (IN6_IS_ADDR_MULTICAST(&dst.sin6_addr)) {
+				recvsock->dst_addr_type = 2;
+				if (multicast_off == 1) {
+					TRACE(dump, "%s - %s", dhcp6r_clock(), 
+					      "RECEIVED MULTICAST PACKET IS DROPPED, ONLY UNICAST "
+					      "IS ALLOWED!\n");
+					return 0;
+				}
+			}
+			else if (IN6_IS_ADDR_LINKLOCAL(&dst.sin6_addr)) {
+				recvsock->dst_addr_type = 3;
+			}
+			else if (IN6_IS_ADDR_SITELOCAL(&dst.sin6_addr))
+          		recvsock->dst_addr_type = 4;
+
+			return 1;
+		}
+	} /* for */
+
+	return 0;
+}
+
+int
+check_select(void) 
+{
+	int i = 0;
+	int flag = 0;
+	struct timeval tv;
+
+	tv.tv_sec  = 0;
+	tv.tv_usec = 0;
+
+	FD_ZERO(&readfd);
+	fdmax = recvsock->recv_sock_desc; /* check the max of them if many 
+	                                     desc used */
+	FD_SET(fdmax, &readfd);
+
+	if ((i = select(fdmax+1, &readfd, NULL, NULL, &tv)) == -1) {
+		TRACE(dump, "%s - %s", dhcp6r_clock(), "Failure in select()\n");
+		return 0;
+	}
+
+	if (FD_ISSET(fdmax, &readfd)) {
+		flag = 1;
+	}
+	else{
+		flag = 0;
+	}
+
+	return flag;
+}
+
+int 
+set_sock_opt() 
+{
+    int on = 1;
+    struct interface *device;
+	int flag; 
+	struct cifaces *iface;
+	struct ipv6_mreq  sock_opt;    
+   
+	if (setsockopt(recvsock->recv_sock_desc, IPPROTO_IPV6, IPV6_PKTINFO, 
+	               &on, sizeof(on) ) < 0) {
+		TRACE(dump, "%s - %s", dhcp6r_clock(), 
+		      "Failed to set socket for IPV6_PKTINFO\n");
+		return 0;
+	}
+
+	for (device = interface_list.next; device != &interface_list;
+	     device = device->next) {   
+		if (cifaces_list.next != &cifaces_list) {
+			flag = 0;
+			for (iface = cifaces_list.next; iface != &cifaces_list; 
+			     iface = iface->next) {	   		
+				if (strcmp(device->ifname, iface->ciface) == 0) {	
+					flag = 1; 
+					break;
+				}    		     		
+			}
+			if (flag == 0)
+				continue;	      	
+		}
+       	
+		sock_opt.ipv6mr_interface = device->devindex;
+    
+		if (inet_pton(AF_INET6, ALL_DHCP_RELAY_AND_SERVERS, 
+		              &sock_opt.ipv6mr_multiaddr) <= 0) {
+			TRACE(dump, "%s - %s", dhcp6r_clock(),
+			      "Failed to set struct for MULTICAST receive\n");
+			return 0;
+		}
+
+		if (setsockopt(recvsock->recv_sock_desc, IPPROTO_IPV6, IPV6_JOIN_GROUP, 
+		               (char *) &sock_opt, sizeof(sock_opt)) < 0) {
+			TRACE(dump, "%s - %s", dhcp6r_clock(), 
+			      "Failed to set socket option for IPV6_JOIN_GROUP \n");
+			return 0;
+		}
+	}
+
+	TRACE(dump, "%s - %s", dhcp6r_clock(),
+	      "SOCKET OPTIONS ARE SET............\n");
+	fflush(dump);
+	return 1;
+}
+
+
+int 
+fill_addr_struct() 
+{
+	bzero((char *)&recvsock->from, sizeof(struct sockaddr_in6));
+	recvsock->from.sin6_family = AF_INET6;
+	recvsock->from.sin6_addr = in6addr_any;
+	recvsock->from.sin6_port = htons(547);
+
+	recvsock->iov[0].iov_base = recvsock->databuf;
+	recvsock->iov[0].iov_len = MAX_DHCP_MSG_LENGTH;
+	recvsock->msg.msg_name = (void *) &recvsock->from;
+	recvsock->msg.msg_namelen = sizeof(recvsock->from);
+	recvsock->msg.msg_iov = &recvsock->iov[0];
+	recvsock->msg.msg_iovlen = 1;
+
+	recvsock->recvmsglen = CMSG_SPACE(sizeof(struct in6_pktinfo));
+	recvsock->recvp = (char *) malloc(recvsock->recvmsglen*sizeof(char));
+	recvsock->msg.msg_control = (void *) recvsock->recvp;
+	recvsock->msg.msg_controllen = recvsock->recvmsglen;
+
+    if (bind(recvsock->recv_sock_desc, (struct sockaddr *)&recvsock->from, 
+	         sizeof(recvsock->from)) < 0) {
+		perror("bind");
+		return 0;
+	}
+
+	return 1;
+}
+
+int 
+recv_data() 
+{
+	int count = -1;
+
+	memset(recvsock->databuf, 0, (MAX_DHCP_MSG_LENGTH*sizeof(char)));
+
+	if ((count = recvmsg(recvsock->recv_sock_desc, &recvsock->msg, 0)) < 0) {
+		TRACE(dump, "%s - %s", dhcp6r_clock(), 
+		      "Failed to receive data with recvmsg()-->Receive::recv_data()\n");
+		return -1;
+	}
+
+	recvsock->buflength = count;
+
+	return 1;
+}
+
+int
+get_interface_info() 
+{
+	FILE *f;
+	char addr6[40], devname[20];
+	struct sockaddr_in6 sap;
+	int plen, scope, dad_status, if_idx;
+	char addr6p[8][5];
+	char src_addr[INET6_ADDRSTRLEN];
+	struct interface *device = NULL;
+	int opaq = OPAQ;
+	int sw = 0;
+	struct IPv6_address *ipv6addr;
+    
+	if ((f = fopen(INTERFACEINFO, "r")) == NULL) {
+		printf("FATAL ERROR-->COULD NOT OPEN FILE: %s\n", INTERFACEINFO);
+		return 0;
+	}         
+
+	while (fscanf(f, "%4s%4s%4s%4s%4s%4s%4s%4s %02x %02x %02x %02x %20s\n",
+	              addr6p[0], addr6p[1], addr6p[2], addr6p[3],addr6p[4], 
+	              addr6p[5], addr6p[6], addr6p[7], &if_idx, &plen, &scope, 
+	              &dad_status, devname) != EOF) {
+		memset(src_addr, 0, INET6_ADDRSTRLEN);
+		sprintf(addr6, "%s:%s:%s:%s:%s:%s:%s:%s", addr6p[0], addr6p[1], 
+		        addr6p[2], addr6p[3],addr6p[4], addr6p[5], addr6p[6], 
+		        addr6p[7]);
+		sap.sin6_family = AF_INET6;
+		sap.sin6_port = 0;
+
+		if (inet_pton(AF_INET6, addr6, sap.sin6_addr.s6_addr) <= 0)
+			return 0;
+
+		if (inet_ntop(AF_INET6, &sap.sin6_addr, src_addr, sizeof(src_addr)) <= 
+		    0)
+			return 0;
+
+		if (IN6_IS_ADDR_LOOPBACK(&sap.sin6_addr))
+			continue;
+
+		sw = 0;
+		for (device = interface_list.next; device != &interface_list;
+		     device = device->next) {
+			if (device->devindex == if_idx) { 
+				sw = 1;    	      
+				break;
+			}    	
+		}	
+
+		if (sw == 0) {      	
+			opaq += 10;
+			device = (struct interface *) malloc(sizeof(struct interface));
+			if (device ==NULL) {
+				TRACE(dump, "%s - %s", dhcp6r_clock(), 
+				      "get_interface_info()--> "
+				      "ERROR NO MORE MEMORY AVAILABLE\n");
+				exit(1);
+			}
+			device->opaq = opaq;	
+			device->ifname = strdup(devname);
+			device->devindex = if_idx;
+			device->ipv6addr = NULL;
+			device->prev = &interface_list;
+			device->next =  interface_list.next;
+			device->prev->next = device;
+			device->next->prev = device;        
+			nr_of_devices += 1;
+		}
+
+		if (IN6_IS_ADDR_LINKLOCAL(&sap.sin6_addr)) {            
+			device->link_local = strdup(src_addr);
+			TRACE(dump,"%s %s %s %d %s %s\n",\
+			      "RELAY INTERFACE INFO-> DEVNAME:", devname, "INDEX:", if_idx,
+			      "LINK_LOCAL_ADDRR:", src_addr);       
+		}
+		else {
+			ipv6addr = (struct IPv6_address *) 
+			           malloc(sizeof(struct IPv6_address));
+			if (ipv6addr ==NULL) {
+				TRACE(dump, "%s - %s", dhcp6r_clock(), 
+				      "get_interface_info()--> "
+				      "ERROR NO MORE MEMORY AVAILABLE\n");
+				exit(1);
+			}
+			ipv6addr->gaddr = strdup(src_addr);
+			ipv6addr->next = NULL;
+			if (device->ipv6addr!= NULL)     	  
+				ipv6addr->next = device->ipv6addr;
+                          
+			device->ipv6addr = ipv6addr;
+		}
+	} /* while */
+    
+	fflush(dump); 
+	for (device = interface_list.next; device != &interface_list;
+	     device = device->next) {	
+		if ( device->ipv6addr == NULL) {
+			TRACE(dump,"%s - ERROR--> ONE MUST ASSIGN SITE SCOPED IPv6 "
+			      "ADDRESS FOR INTERFACE: %s\n", dhcp6r_clock(), 
+			      device->ifname);
+			exit(1);	      	     
+		}
+	}	
+        
+	fclose(f);
+	return 1;
+}
+
+int
+send_message() 
+{
+	struct sockaddr_in6 sin6;    /* my address information */
+	struct msghdr msg;
+	uint32_t count = 0;
+	struct msg_parser *mesg;
+	struct in6_pktinfo *in6_pkt;
+	struct cmsghdr *cmsgp;
+	char dest_addr[INET6_ADDRSTRLEN];    
+	struct IPv6_uniaddr *ipv6uni;
+	struct interface *iface;
+	int hit = 0;    
+	struct iovec iov[1];
+	int recvmsglen;
+	char *recvp;
+	struct server *uservers;
+	struct sifaces *si;
+      
+	if ((mesg = get_send_messages_out()) == NULL)
+		return 0;
+
+	if (mesg->sent == 1)
+		return 0;
+   
+	bzero((char *)&sin6, sizeof(struct sockaddr_in6));
+	sin6.sin6_family = AF_INET6;
+	sin6.sin6_flowinfo = 0;
+	sin6.sin6_scope_id = 0;
+   
+	if (mesg->msg_type == RELAY_REPL) {
+		memset(dest_addr, 0, INET6_ADDRSTRLEN);	
+		memcpy(dest_addr, mesg->peer_addr , INET6_ADDRSTRLEN);
+   
+		recvmsglen = CMSG_SPACE(sizeof(struct in6_pktinfo));
+		recvp = (char *) malloc(recvmsglen*sizeof(char));
+		if (recvp == NULL) {
+			printf("ERROR-->recvp NO MORE MEMORY AVAILABLE \n");
+			exit(1);
+		}
+		memset(recvp, 0, recvmsglen);
+		cmsgp = (struct cmsghdr *) recvp;
+		cmsgp->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
+		cmsgp->cmsg_level = IPPROTO_IPV6;
+		cmsgp->cmsg_type = IPV6_PKTINFO;
+		in6_pkt = (struct in6_pktinfo *) CMSG_DATA(cmsgp);
+		msg.msg_control = (void *) recvp;
+		msg.msg_controllen = recvmsglen;
+
+		/* destination address */
+		if (inet_pton(AF_INET6, dest_addr, &sin6.sin6_addr)<=0) {  
+			TRACE(dump, "%s - %s", dhcp6r_clock(),
+			      "send_message()--> inet_pton FAILED \n");
+           exit(1);
+		}  
+		sin6.sin6_scope_id = mesg->if_index;
+
+		if (mesg->hop > 0)
+			sin6.sin6_port = htons(SERVER_PORT);
+		else
+			sin6.sin6_port = htons(CLIENT_PORT);    
+      
+		iface = get_interface(mesg->if_index);
+
+		if (iface != NULL) {
+			if (inet_pton(AF_INET6, iface->ipv6addr->gaddr, 
+			              &in6_pkt->ipi6_addr) <= 0) {  /* source address */
+				TRACE(dump, "%s - %s", dhcp6r_clock(),
+				      "inet_pton failed in send_message()\n");
+				exit(1);
+			}
+			TRACE(dump, "%s - SOURCE ADDRESS: %s\n", dhcp6r_clock(), 
+			      iface->ipv6addr->gaddr);
+        }
+		else {
+			/* the kernel will choose the source address */
+			memset(&in6_pkt->ipi6_addr, 0, sizeof(in6_pkt->ipi6_addr)); 
+        }
+
+		/* OUTGOING DEVICE FOR RELAY_REPLY MSG */
+		in6_pkt->ipi6_ifindex = mesg->if_index;        
+		TRACE(dump, "%s - OUTGOING DEVICE INDEX: %d\n", dhcp6r_clock(), 
+		      in6_pkt->ipi6_ifindex);
+		TRACE(dump, "%s - DESTINATION PORT: %d\n", dhcp6r_clock(), 
+		      ntohs(sin6.sin6_port));
+
+		iov[0].iov_base = mesg->buffer;
+		iov[0].iov_len = mesg->datalength;
+		msg.msg_name = (void *) &sin6;
+		msg.msg_namelen = sizeof(sin6);
+		msg.msg_iov = &iov[0];
+		msg.msg_iovlen = 1;
+
+		if ((count = sendmsg(sendsock->send_sock_desc, &msg, 0)) < 0) { 
+			perror("sendmsg");
+			return 0;
+		}
+
+		if (count > MAX_DHCP_MSG_LENGTH)
+			perror("bytes in sendmsg");
+             
+		TRACE(dump, "%s - *********> RELAY_REPL, SENT TO: %s SENT_BYTES: %d\n", 
+		      dhcp6r_clock(), dest_addr, count);
+                       
+		free(recvp);
+      
+		mesg->sent = 1;
+		return 1;   
+	}
+
+	if (mesg->msg_type == RELAY_FORW) {
+		for (ipv6uni = IPv6_uniaddr_list.next; ipv6uni != &IPv6_uniaddr_list; 
+		     ipv6uni = ipv6uni->next) {
+			bzero((char *)&sin6, sizeof(struct sockaddr_in6));
+			sin6.sin6_family = AF_INET6;
+ 
+			memset(dest_addr, 0, INET6_ADDRSTRLEN);	
+			memcpy(dest_addr, ipv6uni->uniaddr , INET6_ADDRSTRLEN);
+       
+			/* destination address */
+			if (inet_pton(AF_INET6, dest_addr, &sin6.sin6_addr) <= 0) {  
+				TRACE(dump,"%s - %s",dhcp6r_clock(),
+				      "inet_pton failed in send_message()\n");
+				return 0;
+			}
+
+			recvmsglen = CMSG_SPACE(sizeof(struct in6_pktinfo));
+			recvp = (char *) malloc(recvmsglen*sizeof(char));
+			if (recvp == NULL) {
+				TRACE(dump, "%s - %s", dhcp6r_clock(), 
+				      "ERROR-->recvp NO MORE MEMORY AVAILABLE \n");
+				exit(1);
+			}
+			memset(recvp, 0, recvmsglen);
+
+			cmsgp = (struct cmsghdr *) recvp;
+			cmsgp->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
+			cmsgp->cmsg_level = IPPROTO_IPV6;
+			cmsgp->cmsg_type = IPV6_PKTINFO;
+			in6_pkt = (struct in6_pktinfo *) CMSG_DATA(cmsgp);
+			msg.msg_control = (void *) recvp;
+			msg.msg_controllen = recvmsglen;
+
+		 	/* destination address */	
+			if (inet_pton(AF_INET6, dest_addr, &sin6.sin6_addr)<=0) { 
+				TRACE(dump, "%s - %s", dhcp6r_clock(),
+				      "inet_pton failed in send_message()\n");
+				return 0;
+			}  
+			sin6.sin6_scope_id = 0;  
+			sin6.sin6_port = htons(SERVER_PORT);
+     
+			/* the kernel will choose the source address */	
+			memset(&in6_pkt->ipi6_addr, 0, sizeof(in6_pkt->ipi6_addr)); 
+		 	/* OUTGOING DEVICE FOR RELAY_REPLY MSG */	
+			in6_pkt->ipi6_ifindex = 0; 
+
+			iov[0].iov_base = mesg->buffer;
+			iov[0].iov_len = mesg->datalength;
+			msg.msg_name = (void *) &sin6;
+			msg.msg_namelen = sizeof(sin6);
+			msg.msg_iov = &iov[0];
+			msg.msg_iovlen = 1;
+
+			if ((count = sendmsg(sendsock->send_sock_desc, &msg, 0)) < 0) {     
+				perror("sendmsg");	
+				return 0;
+			}
+
+			if (count > MAX_DHCP_MSG_LENGTH)
+				perror("bytes sendmsg");
+             
+			TRACE(dump,
+			      "%s - ========> RELAY_FORW, SENT TO: %s SENT_BYTES: %d\n", 
+			      dhcp6r_clock(), dest_addr, count);     
+			free(recvp);
+			hit = 1;
+		} /* for */
+   
+		for (iface = interface_list.next;  iface!= &interface_list;  
+	     	 iface = iface->next) {        	
+			uservers = iface->sname;
+			while (uservers != NULL) { 	
+				bzero((char *)&sin6, sizeof(struct sockaddr_in6));
+				sin6.sin6_family = AF_INET6;
+
+				memset(dest_addr, 0, INET6_ADDRSTRLEN);      
+				memcpy(dest_addr, uservers->serv  , INET6_ADDRSTRLEN);
+       
+				/* destination address */
+				if (inet_pton(AF_INET6, dest_addr, &sin6.sin6_addr) <= 0) {  
+					TRACE(dump, "%s - %s", dhcp6r_clock(),
+					      "inet_pton failed in send_message()\n");
+					exit(1);
+				}
+
+				recvmsglen = CMSG_SPACE(sizeof(struct in6_pktinfo));
+				recvp = (char *) malloc(recvmsglen*sizeof(char));
+				if (recvp == NULL) {
+					TRACE(dump, "%s - %s", dhcp6r_clock(),
+					      "ERROR-->recvp NO MORE MEMORY AVAILABLE \n");
+					exit(1);
+				}
+				memset(recvp, 0, recvmsglen);
+
+				cmsgp = (struct cmsghdr *) recvp;
+				cmsgp->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
+				cmsgp->cmsg_level = IPPROTO_IPV6;
+				cmsgp->cmsg_type = IPV6_PKTINFO;
+				in6_pkt = (struct in6_pktinfo *) CMSG_DATA(cmsgp);
+				msg.msg_control = (void *) recvp;
+				msg.msg_controllen = recvmsglen;
+
+				/* destination address */
+				if (inet_pton(AF_INET6, dest_addr, &sin6.sin6_addr) <= 0) {  
+					TRACE(dump, "%s - %s", dhcp6r_clock(),
+					      "inet_pton failed in send_message()\n");
+					return 0;
+				} 
+     
+				in6_pkt->ipi6_ifindex = iface->devindex;  
+				sin6.sin6_scope_id = in6_pkt->ipi6_ifindex;
+     
+				TRACE(dump, "%s - OUTGOING DEVICE INDEX: %d\n", dhcp6r_clock(), 
+				      in6_pkt->ipi6_ifindex);
+				if (inet_pton(AF_INET6, iface->ipv6addr->gaddr, 
+				              &in6_pkt->ipi6_addr) <= 0) {  /* source address */
+					TRACE(dump,"%s - %s",dhcp6r_clock(),
+					      "inet_pton failed in send_message()\n");
+					exit(1);
+				}
+				TRACE(dump, "%s - SOURCE ADDRESS: %s\n", dhcp6r_clock(), 
+				      iface->ipv6addr->gaddr);
+               
+				sin6.sin6_port = htons(SERVER_PORT);
+    
+				iov[0].iov_base = mesg->buffer;
+				iov[0].iov_len = mesg->datalength;
+				msg.msg_name = (void *) &sin6;
+				msg.msg_namelen = sizeof(sin6);
+				msg.msg_iov = &iov[0];
+				msg.msg_iovlen = 1;
+
+				if ((count = sendmsg(sendsock->send_sock_desc, &msg, 0)) < 0) {
+					perror("sendmsg");	
+					return 0;
+				}
+
+				if (count > MAX_DHCP_MSG_LENGTH)
+					perror("bytes sendmsg");
+             
+				TRACE(dump, 
+				      "%s - ========> RELAY_FORW, SENT TO: %s SENT_BYTES: %d\n",
+				      dhcp6r_clock(), dest_addr, count);
+				free(recvp);
+				uservers = uservers->next;
+				hit = 1;  
+			} /* while */
+		} /* Interfaces */
+   
+		for (si = sifaces_list.next;  si != &sifaces_list; si = si->next) {
+			*(mesg->hc_pointer)= MAXHOPCOUNT;
+			bzero((char *)&sin6, sizeof(struct sockaddr_in6));
+			sin6.sin6_family = AF_INET6;
+    
+			memset(dest_addr, 0, INET6_ADDRSTRLEN);	
+			strcpy(dest_addr, ALL_DHCP_SERVERS);
+       
+			/* destination address */	
+			if (inet_pton(AF_INET6, dest_addr, &sin6.sin6_addr) <= 0) {  
+				TRACE(dump, "%s - %s", dhcp6r_clock(),
+				      "inet_pton failed in send_message()\n");
+				return 0;
+			}
+
+			recvmsglen = CMSG_SPACE(sizeof(struct in6_pktinfo));
+			recvp = (char *) malloc(recvmsglen*sizeof(char));
+			if (recvp == NULL) {
+				TRACE(dump, "%s - %s", dhcp6r_clock(),
+				      "ERROR-->recvp NO MORE MEMORY AVAILABLE \n");
+				exit(1);
+			}
+			memset(recvp, 0, recvmsglen);
+
+			cmsgp = (struct cmsghdr *) recvp;
+			cmsgp->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
+			cmsgp->cmsg_level = IPPROTO_IPV6;
+			cmsgp->cmsg_type = IPV6_PKTINFO;
+			in6_pkt = (struct in6_pktinfo *) CMSG_DATA(cmsgp);
+			msg.msg_control = (void *) recvp;
+			msg.msg_controllen = recvmsglen;
+
+			/* destination address */	
+			if (inet_pton(AF_INET6, dest_addr, &sin6.sin6_addr) <= 0) {  
+				TRACE(dump,"%s - %s",dhcp6r_clock(),
+				      "inet_pton failed in send_message()\n");
+				return 0;
+			} 
+     
+			in6_pkt->ipi6_ifindex = if_nametoindex(si->siface);  
+			sin6.sin6_scope_id = in6_pkt->ipi6_ifindex;
+   
+			TRACE(dump, "%s - OUTGOING DEVICE INDEX: %d\n", dhcp6r_clock(), 
+			      in6_pkt->ipi6_ifindex);
+			iface = get_interface(in6_pkt->ipi6_ifindex);
+			if (iface == NULL) {
+				TRACE(dump, "%s - %s", dhcp6r_clock(),
+				      "ERROR--> send_message(), NO INTERFACE INFO FOUND\n");
+				exit(0);
+			} 
+			if (inet_pton(AF_INET6, iface->ipv6addr->gaddr, 
+			              &in6_pkt->ipi6_addr)<=0) {  /* source address */
+             	TRACE(dump, "%s - %s", dhcp6r_clock(),
+				      "inet_pton failed in send_message()\n");
+             	exit(1);
+			}
+			TRACE(dump,"%s - SOURCE ADDRESS: %s\n",dhcp6r_clock(), 
+			      iface->ipv6addr->gaddr);
+     	           
+			sin6.sin6_port = htons(SERVER_PORT);
+    
+			iov[0].iov_base = mesg->buffer;
+			iov[0].iov_len = mesg->datalength;
+			msg.msg_name = (void *) &sin6;
+			msg.msg_namelen = sizeof(sin6);
+			msg.msg_iov = &iov[0];
+			msg.msg_iovlen = 1;
+
+			if ((count = sendmsg(sendsock->send_sock_desc, &msg, 0)) < 0) {
+				perror("sendmsg");	    
+				return 0;
+			}
+
+			if (count > MAX_DHCP_MSG_LENGTH)
+				perror("bytes sendmsg");
+             
+			TRACE(dump, 
+			      "%s - ========> RELAY_FORW, SENT TO: %s SENT_BYTES: %d\n", 
+			     dhcp6r_clock(), dest_addr, count);
+      
+			free(recvp);
+			hit = 1;
+		} /* for */
+   
+		if (hit == 0) {
+			for (iface = interface_list.next;  iface != &interface_list;
+		     	iface = iface->next) {
+				if (mesg->interface_in == iface->devindex)   
+					continue;
+
+				*(mesg->hc_pointer)= MAXHOPCOUNT;
+				bzero((char *)&sin6, sizeof(struct sockaddr_in6));
+				sin6.sin6_family = AF_INET6;
+
+				memset(dest_addr, 0, INET6_ADDRSTRLEN);
+				strcpy(dest_addr, ALL_DHCP_SERVERS);
+
+				/* destination address */
+				if (inet_pton(AF_INET6, dest_addr, &sin6.sin6_addr) <= 0) {  
+					TRACE(dump, "%s - %s", dhcp6r_clock(),
+					      "inet_pton failed in send_message()\n");
+					return 0;
+				}
+
+				recvmsglen = CMSG_SPACE(sizeof(struct in6_pktinfo));
+				recvp = (char *) malloc(recvmsglen*sizeof(char));
+				if (recvp ==NULL) {
+					TRACE(dump, "%s - %s", dhcp6r_clock(),
+					      "ERROR-->recvp NO MORE MEMORY AVAILABLE \n");
+					exit(1);
+				}
+				memset(recvp, 0, recvmsglen);
+
+				cmsgp = (struct cmsghdr *) recvp;
+				cmsgp->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
+				cmsgp->cmsg_level = IPPROTO_IPV6;
+				cmsgp->cmsg_type = IPV6_PKTINFO;
+				in6_pkt = (struct in6_pktinfo *) CMSG_DATA(cmsgp);
+				msg.msg_control = (void *) recvp;
+				msg.msg_controllen = recvmsglen;
+
+		 		/* destination address */	
+				if (inet_pton(AF_INET6, dest_addr, &sin6.sin6_addr) <= 0) { 
+					TRACE(dump, "%s - %s", dhcp6r_clock(),
+					      "inet_pton failed in send_message()\n");
+					return 0;
+				}
+				sin6.sin6_port = htons(SERVER_PORT);
+
+				in6_pkt->ipi6_ifindex = iface->devindex;
+				sin6.sin6_scope_id = in6_pkt->ipi6_ifindex;
+   
+				TRACE(dump, "%s - OUTGOING DEVICE INDEX: %d\n", dhcp6r_clock(), 
+				      in6_pkt->ipi6_ifindex);
+				if (inet_pton(AF_INET6, iface->ipv6addr->gaddr, 
+				              &in6_pkt->ipi6_addr)<=0) {  /* source address */
+					TRACE(dump, "%s - %s", dhcp6r_clock(),
+					      "inet_pton failed in send_message()\n");
+					exit(1);
+				}
+     
+				TRACE(dump, "%s - SOURCE ADDRESS: %s\n", dhcp6r_clock(), 
+				      iface->ipv6addr->gaddr);
+     
+				iov[0].iov_base = mesg->buffer;
+				iov[0].iov_len = mesg->datalength;
+				msg.msg_name = (void *) &sin6;
+				msg.msg_namelen = sizeof(sin6);
+				msg.msg_iov = &iov[0];
+				msg.msg_iovlen = 1;
+
+				if ((count = sendmsg(sendsock->send_sock_desc, &msg, 0))< 0) {
+					perror("sendmsg");            
+					return 0;
+				}
+
+				if (count > MAX_DHCP_MSG_LENGTH)
+					perror("sendmsg");
+
+				TRACE(dump, 
+				      "%s - ========> RELAY_FORW, SENT TO: %s SENT_BYTES: %d\n",
+				      dhcp6r_clock(), dest_addr, count);
+				free(recvp);
+			} /* for */
+		}
+	}
+
+	fflush(dump);
+	mesg->sent = 1;
+	return 1;  
+       
+
+	TRACE(dump, "%s - %s", dhcp6r_clock(), 
+	      "FATAL ERROR--> NO MESSAGE TYPE TO BE SENT!\n");
+	exit(1);
+}
--- /dev/null	2007-02-06 10:40:24.955607220 -0500
+++ dhcp-0.10/relay6_socket.h	2007-02-09 00:16:08.000000000 -0500
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) NEC Europe Ltd., 2003
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef __RELAY6_SOCKET_H_DEFINED
+#define __RELAY6_SOCKET_H_DEFINED
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
+#include "dhcp6r.h"
+
+fd_set readfd;
+int fdmax;  
+
+struct receive {
+	struct msghdr msg;
+	struct iovec iov[1];
+	struct cmsghdr *cmsgp;
+	struct sockaddr_in6 sin6;    /* my address information */
+	struct sockaddr_in6 from;
+	int recvmsglen;
+	char *recvp;
+	char src_addr[INET6_ADDRSTRLEN];
+	int pkt_interface;
+	int buflength;
+	int dst_addr_type ;
+	char *databuf;
+	int recv_sock_desc;
+};
+
+struct send {
+	int send_sock_desc;
+};
+
+struct send  *sendsock;
+struct receive *recvsock;
+
+int send_message __P((void));
+int fill_addr_struct __P((void));
+int set_sock_opt __P((void));
+int recv_data __P((void));
+int check_select __P((void));
+int get_recv_data __P((void));
+int get_interface_info __P((void));
+void init_socket __P((void));
+
+#endif /* __RELAY6_SOCKET_H_DEFINED */
